{
	"info": {
		"_postman_id": "eb81f53c-b304-4b15-a033-1b2cd41d478b",
		"name": "OCI PLC Collection",
		"description": "# Salesforce Commerce Omnichannel Inventory Partner Postman Collection\n\nThis postman collection contains API endpoints from various Salesforce Commerce domains, but the emphasis is uploading inventory levels, monitoring or deleting jobs in that regard, and getting availability levels through the Connect API.\n\nUnlike many other Postman collections, this one is meant to be _user friendly_ and have _meaningful error messages_ when something is not set up correctly or there are issues in the request chains.\n\nThis collection supports the Partner Learning Camp course \"Order Management: Omnichannel Inventory\" more specifically, the activity \"Explore Omnichannel Inventory Headless APIs\" where you can find all the needed steps for setting up OpenSSL and the JSON Web Token.\n\n## ⚠️ Disclaimers\n\n- This collection is provided as-is. It's not officially supported by Salesforce or covered by SLAs.\n- API documentation is not provided with the collection. Please refer to the official documentation.\n- The documentation for the majority of the endpoints in this collection can be found in the Omnichannel Inventory section of the Omnichannel Inventory Headless API and Connect API documentation.\n    \n## Standardized variables (also documented in the Postman collection)\n\n⚠️ **_Note_**: The naming convention found here is used across other Salesforce Commerce product Postman collections in the Partner Readiness space when possible to support reuse.\n\nThis Postman collection relies on the following variables:\n\n| Name | Description | Location |\n| --- | --- | --- |\n| `host` | The OCI Host for the Salesforce Org | Setup > Omnichannel Inventory > 'Base URL for Inventory API Calls' |\n| `tenantId` | The OCI Tenant Id for the Salesforce org | Setup > Omnichannel Inventory > 'Tenant Group ID' |\n| `JWT` | JSON Web Token | Consult the course for setup procedure |\n| `bearerToken` | The bearer token sent in the Authorization header | Autogenerated |\n| `productStockKeepingUnitsCommaDelimited` | The Stock Keeping Unit(s) for the products needing inventory levels | User supplied. Must be comma delimited. Example 1: `PROSE,B-C-COFMAC-001,ESP-IOT-1,ID-PEM,PS-EL,PS-INF,TR-COFMAC-001` Example 2: `ID-PEM`  |\n| `locationGroupIdentifiersCommaDelimited` | The Location Group(s) for the availability query | User supplied. Must be comma delimited. Example 1: `LocationGroup01` Example 2: `LocationGroup01,LocationGroup02,WestCoastDistributionChain` |\n| `locationIdentifiersCommaDelimited` |  The Location(s) for the availability query | User supplied. Must be comma delimited. Example 1: `Warehouse01` Example 2: `Warehouse01,Store056,Pier37` |\n| `importsUploadLinkPostBody` | The pseudo JSON file content posted for inventory level uploads | Provided for example products and can be modified to suit your needs |\n| `orgHost` | Protocol and host portion of the Salesforce org's URL | User supplied. Example: `https://yourusername-august.lightning.force.com` |\n| `orgAdminUsername` | The System Administrator username for the Salesforce org | User supplied |\n| `orgAdminPassword` | The System Administrator password for the Salesforce org | User supplied |\n| `orgAdminSecurityToken` | The security token for the Salesforce Org System Administrator User | Autogenerated |\n| `orgHostMySalesforceFormat` | The protocol and host portion of the Salesforce org's URL in 'my.salesforce.com' format. Useful for avoiding redirection problems and 'Invalid Session Id' errors post authentication | User supplied. Example: `https://yourusername-august.my.salesforce.com` |\n| `apiVersion` | The Salesforce API version (e.g. 58.0). | User supplied. Most recent value recommended. |\n| `connectedAppConsumerKey` | The Consumer Secret value for the Connected App in the Salesforce org. | Setup > App Manager > Connected App Record > View > Manage Consumer Details |\n| `connectedAppConsumerSecret` | The Consumer Secret value in the Connected App. | Setup > App Manager > Connected App Record > View > Manage Consumer Details |\n| `orgLoginUrl` | Either `https://login.salesforce.com` (production/trial) or `https://test.salesforce.com` (sandbox) | User supplied |\n| `orgId` | The Salesforce.com Organization ID for the Salesforce org | Setup > Company Information |\n| `webstoreName` | Name of the webstore used to look up a corresponding Id | The value specified when the store / site was created such as 'B2B LWR Enhanced Store from TSO.' Can be found in the Commerce App under 'Stores.' |\n| `buyerUsername` | Registered B2B Buyer User's username. | User supplied. |\n| `buyerPassword` | Registered B2B Buyer User's password. | User supplied. |\n| `buyerAccountName` | Name of the Account used to look up the Accoujnt Id which is tied to the Buyer User. | User supplied. Example: `United Coffee Bean Corp` |\n\nConsult the course documentation for additional details.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "8399406"
	},
	"item": [
		{
			"name": "Upload Inventory (Happy Path)",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Get Access Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let jsonData = pm.response.json();\r",
									"pm.environment.set('bearerToken','Bearer ' + jsonData.access_token);"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.expect(pm.environment.name !== null);\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','JWT'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Host",
								"value": "login.salesforce.com",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "grant_type",
									"value": "urn:ietf:params:oauth:grant-type:jwt-bearer",
									"type": "text"
								},
								{
									"key": "assertion",
									"value": "{{JWT}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/oauth2/token",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Authenticate into Org",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 204', () => {",
									"    pm.response.to.have.status(204);",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.expect(pm.environment.name !== null);\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'tenantId', 'bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/internal/v1/organizations/{{tenantId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"internal",
								"v1",
								"organizations",
								"{{tenantId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Inventory Import Link",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));",
									"",
									"pm.expect(pm.environment.name !== null);",
									"",
									"// Expected strings in environment variables",
									"['host', 'tenantId', 'bearerToken', 'locationInventoryImportInitiateBody'].forEach(esiev => {",
									"    if(!pm.environment.has(esiev)) {",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;",
									"        pm.expect.fail(msg);",
									"    }",
									"    pm.expect(pm.environment.get(esiev)).to.exist;",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');",
									"});",
									"",
									"let importInitiateBody = JSON.stringify({'fileName': pm.environment.get('locationInventoryImportFileName'),'linkDuration': 60});",
									"pm.environment.set('locationInventoryImportInitiateBody',importInitiateBody);",
									"",
									"pm.environment.set('locationInventoryImportId',null);",
									"pm.environment.set('locationInventoryImportStatusLink',null);",
									"pm.environment.set('locationInventoryImportUploadLink',null);",
									"pm.environment.set('locationInventoryImportResultsLink',null);",
									"",
									"// Reset to account for the other imports/exports using the same variable",
									"pm.environment.set('countOfStatusCheck',null);"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 200', () => {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response is valid and has a JSON body', () => {",
									"     pm.response.to.be.success;",
									"     pm.response.to.be.withBody;",
									"     pm.response.to.be.json;",
									"});",
									"",
									"/*",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.",
									"*/",
									"try {",
									"    const jsonData = pm.response.json();",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);",
									"} catch(e) {",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"type": "text",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{{locationInventoryImportInitiateBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				},
				{
					"name": "5. Post Inventory Import File",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'locationInventoryImportUploadLink', 'importsUploadLinkPostBody'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "ImportsUploadLinkPostBody",
									"value": "{{importsUploadLinkPostBody}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{host}}{{locationInventoryImportUploadLink}}",
							"host": [
								"{{host}}{{locationInventoryImportUploadLink}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "6. Get Inventory Import Status",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 200', () => {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"let currentStatus = utils.evaluateStatusCheck(pm, postman, 'locationInventoryImportStatus', 'Location inventory import, ');",
									"pm.expect(currentStatus).to.be.oneOf(['retry', 'success']);",
									"",
									"switch (currentStatus) {",
									"    case 'retry':",
									"        setTimeout(function() {}, 3000);",
									"        break;",
									"    case 'success':",
									"        let jsonData = pm.response.json();",
									"        let locationInventoryImportResultsLink = jsonData.import.fullResults.href;",
									"        pm.environment.set('locationInventoryImportResultsLink', locationInventoryImportResultsLink);",
									"        break;",
									"    default:",
									"        pm.expect.fail('currentStatus was not retry or success');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.expect(pm.environment.name !== null);\r",
									"pm.expect(pm.environment.get('locationInventoryImportStatusLink')).to.exist;\r",
									"pm.expect(pm.environment.get('locationInventoryImportStatusLink')).to.be.an('string');\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'locationInventoryImportStatusLink', 'bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}{{locationInventoryImportStatusLink}}",
							"host": [
								"{{host}}{{locationInventoryImportStatusLink}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "7. Get Inventory Import Results",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"utils.responseCodeCheck(pm, postman, 200, request);",
									"",
									"try {",
									"    //this will fail if there are errors, because the response body when there are errors is not standard json and can't be converted to json.",
									"    let jsonData = pm.response.json();",
									"    let currentStatus = jsonData.status;",
									"    console.log('Final result status is: ' + currentStatus);",
									"    pm.expect(currentStatus).to.eql('COMPLETED_WITHOUT_ERRORS');",
									"} catch (err) {",
									"    postman.setNextRequest(null);",
									"    pm.expect.fail('There were errors importing. See the response body for specifics.')",
									"}",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'locationInventoryImportResultsLink', 'bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}{{locationInventoryImportResultsLink}}",
							"host": [
								"{{host}}{{locationInventoryImportResultsLink}}"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get Import Jobs",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Get Access Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let jsonData = pm.response.json();\r",
									"pm.environment.set('bearerToken','Bearer ' + jsonData.access_token);\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','JWT'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Host",
								"value": "login.salesforce.com",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "grant_type",
									"value": "urn:ietf:params:oauth:grant-type:jwt-bearer",
									"type": "text"
								},
								{
									"key": "assertion",
									"value": "{{JWT}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/oauth2/token",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Authenticate into Org",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 204', () => {",
									"    pm.response.to.have.status(204);",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/internal/v1/organizations/{{tenantId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"internal",
								"v1",
								"organizations",
								"{{tenantId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Jobs",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response and save the import job ids array to collection variables', () => {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.expect(jsonData.imports).to.exist;\r",
									"    pm.expect(jsonData.imports).to.be.an('array');\r",
									"    const importJobIds = jsonData.imports;\r",
									"    console.log('Number of Import Job Ids: ' + importJobIds.length + ' Details:\\r\\n' + importJobIds.join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_importJobIds', importJobIds);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get and Delete Import Jobs",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Get Access Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let jsonData = pm.response.json();\r",
									"pm.environment.set(\"bearerToken\",\"Bearer \" + jsonData.access_token);"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','JWT'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Host",
								"value": "login.salesforce.com",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "grant_type",
									"value": "urn:ietf:params:oauth:grant-type:jwt-bearer",
									"type": "text"
								},
								{
									"key": "assertion",
									"value": "{{JWT}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "https://login.salesforce.com/services/oauth2/token",
							"protocol": "https",
							"host": [
								"login",
								"salesforce",
								"com"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Authenticate into Org",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 204', () => {",
									"    pm.response.to.have.status(204);",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/internal/v1/organizations/{{tenantId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"internal",
								"v1",
								"organizations",
								"{{tenantId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Jobs",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Validate the response and save the import job ids array to collection variables', () => {\r",
									"    pm.expect(jsonData.imports).to.exist;\r",
									"    pm.expect(jsonData.imports).to.be.an('array');\r",
									"    const importJobIds = jsonData.imports;\r",
									"    console.log('Number of Import Job Ids: ' + importJobIds.length + ' Details:\\r\\n' + importJobIds.join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_importJobIds', importJobIds);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				},
				{
					"name": "5. Delete First Job in Collection",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.test('Status code is 204', () => {\r",
									"    pm.response.to.have.status(204);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"const importJobIds = pm.collectionVariables.get('_importJobIds');\r",
									"\r",
									"if(importJobIds === undefined || importJobIds === null || importJobIds.length === 0) {\r",
									"    pm.expect.fail('No jobs to delete. Try running the \"Upload Inventory (Happy Path)\" folder once or twice to create some.');\r",
									"}\r",
									"\r",
									"pm.collectionVariables.set('_importJobId', importJobIds[0]);\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"// Expected strings in collection variables\r",
									"['_importJobId'].forEach(esicv => {\r",
									"    if(!pm.collectionVariables.has(esicv)) {\r",
									"        const msg = 'Expected Postman collection variable not found: ' + esicv;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.exist;\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports/{{_importJobId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports",
								"{{_importJobId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "6. Get Jobs",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Validate the response and save the import job ids array to collection variables', () => {\r",
									"    pm.expect(jsonData.imports).to.exist;\r",
									"    pm.expect(jsonData.imports).to.be.an('array');\r",
									"    const importJobIds = jsonData.imports;\r",
									"    console.log('Number of Import Job Ids: ' + importJobIds.length + ' Details:\\r\\n' + importJobIds.join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_importJobIds', importJobIds);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get Availability (Log In Flow + Connect API)",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Authenticate Connected App",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.ok;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the access token is found in the body and save it to the variables', () => {\r",
									"    const data = pm.response.json();\r",
									"    pm.expect(data.token_type).to.exist;\r",
									"    pm.expect(data.token_type).to.be.a.string;\r",
									"    pm.expect(data.access_token).to.exist;\r",
									"    pm.expect(data.access_token).to.be.a.string;\r",
									"    const id = data.id.split('/');\r",
									"\r",
									"    pm.collectionVariables.set('_token', data.access_token);\r",
									"    pm.collectionVariables.set('_instanceUrl', data.instance_url);\r",
									"    pm.collectionVariables.set('_userId', id.pop());\r",
									"    pm.collectionVariables.set('_orgId', id.pop());\r",
									"});\r",
									"\r",
									"console.debug('token: ' + pm.collectionVariables.get('_token'));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','JWT'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "{{orgAdminUsername}}",
									"type": "text"
								},
								{
									"key": "password",
									"value": "{{orgAdminPassword}}{{orgAdminSecurityToken}}",
									"type": "text"
								},
								{
									"key": "grant_type",
									"value": "password",
									"type": "text"
								},
								{
									"key": "client_id",
									"value": "{{connectedAppConsumerKey}}",
									"type": "text"
								},
								{
									"key": "client_secret",
									"value": "{{connectedAppConsumerSecret}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/oauth2/token",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Log in as System Administrator (SOAP)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(JSON.parse(JSON.stringify(pm.collectionVariables.values)).map((v) => v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Validate the access token is found in the body and save it to the variables', () => {\r",
									"    const result = xml2Json(pm.response.text())['soapenv:Envelope']['soapenv:Body'].loginResponse.result;\r",
									"    const url = result.serverUrl.split('/');\r",
									"\r",
									"    pm.expect(result.sessionId).to.exist;\r",
									"    pm.expect(result.sessionId).to.be.a.string;\r",
									"\r",
									"    pm.collectionVariables.set('_token', result.sessionId);\r",
									"    pm.collectionVariables.set('_instanceUrl', url[0] + '//' + url[2]);\r",
									"    pm.collectionVariables.set('_userId', result.userId);\r",
									"    pm.collectionVariables.set('_orgId', result.userInfo.organizationId);\r",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "text/xml; charset=UTF-8",
								"type": "text"
							},
							{
								"key": "SOAPAction",
								"value": "login",
								"type": "text"
							},
							{
								"key": "Accept",
								"value": "text/xml",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<env:Envelope xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:n1=\"urn:partner.soap.sforce.com\"\r\n    xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\">\r\n    <env:Body>\r\n        <n1:login>\r\n            <n1:username><![CDATA[{{orgAdminUsername}}]]></n1:username>\r\n            <n1:password><![CDATA[{{orgAdminPassword}}]]></n1:password>\r\n        </n1:login>\r\n    </env:Body>\r\n</env:Envelope>"
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/Soap/u/{{apiVersion}}",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"Soap",
								"u",
								"{{apiVersion}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Availability by Location Group",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationGroupIdentifiers...');\r",
									"const locationGroupIdsCommaDelimited = pm.environment.get('locationGroupIdentifiersCommaDelimited');\r",
									"const locationGroupIdsArray = locationGroupIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Group Identifiers: ' + locationGroupIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationGroupIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationGroupIdentifiers', JSON.stringify(locationGroupIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + productStockKeepingUnitsArray.join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"    \r",
									"    const locationGroups = jsonData.locationGroups;\r",
									"    console.log('Number of Location Groups: ' + locationGroups.length + ' Details:\\r\\n' + JSON.stringify(locationGroups).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locationGroups', locationGroups);\r",
									"    pm.expect(locationGroups.length > 0);\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.exist;\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.be.an('String');\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0]).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationGroupIdentifiers\": {{_locationGroupIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{orgHostMySalesforceFormat}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{orgHostMySalesforceFormat}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				},
				{
					"name": "5. Get Availability by Location",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationIdentifiers...');\r",
									"const locationIdsCommaDelimited = pm.environment.get('locationIdentifiersCommaDelimited');\r",
									"const locationIdsArray = locationIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Identifiers: ' + locationIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationIdentifiers', JSON.stringify(locationIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + JSON.stringify(productStockKeepingUnitsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"\r",
									"    const locations = jsonData.locations;\r",
									"    console.log('Number of Locations: ' + locations.length + ' Details:\\r\\n' + JSON.stringify(locations).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locations', locations);\r",
									"    pm.expect(locations.length > 0);\r",
									"    pm.expect(locations[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.exist;\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationIdentifiers\": {{_locationIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{orgHostMySalesforceFormat}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{orgHostMySalesforceFormat}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get Availability (oAuth Flow + Connect API)",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Set your oAuth 2.0 Token in Authorization tab",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Checking oAuth has been set up...');\r",
									"\r",
									"const isTokenMissing = pm.request.auth === undefined\r",
									"    || pm.request.auth.oauth2 === undefined\r",
									"    || !pm.request.auth.oauth2.has('accessToken')\r",
									"    || pm.request.auth.oauth2.get('accessToken') === undefined\r",
									"    || pm.request.auth.oauth2.get('accessToken') === null\r",
									"    || pm.request.auth.oauth2.get('accessToken').length === 0;\r",
									"\r",
									"pm.test('oAuth 2.0 Token is present', () => {\r",
									"    pm.expect(isTokenMissing === false);\r",
									"    pm.expect(pm.request.auth).to.exist;\r",
									"    pm.expect(pm.request.auth).to.be.an('object');\r",
									"    pm.expect(pm.request.auth.oauth2).to.exist;\r",
									"    pm.expect(pm.request.auth.oauth2).to.be.an('object');\r",
									"    pm.expect(pm.request.auth.oauth2.has('accessToken')).to.be.true;\r",
									"    pm.expect(pm.request.auth.oauth2.get('accessToken')).to.exist;\r",
									"    pm.expect(pm.request.auth.oauth2.get('accessToken')).to.be.an('string').with.length.greaterThan(0);\r",
									"});\r",
									"\r",
									"if(isTokenMissing) {\r",
									"    const msg = 'No Soup for you! oAuth 2.0 token not found. Steps to fix the issue:\\r\\n' + \r",
									"    '1. Click on the Request with a name like \"Set your oAuth 2.0 Token here in Authorization tab\"\\r\\n' +\r",
									"    '2. Click the \"Authorization\" tab\\r\\n' + \r",
									"    '3. Click the \"Get New Access Token\" button\\r\\n' +\r",
									"    '4. Click the \"Proceed\" button\\r\\n' + \r",
									"    '5. Click the \"Use Token\" button\\r\\n' +\r",
									"    '6. Retry your request';\r",
									"    console.log(msg);\r",
									"    pm.expect.fail('No Soup for you! oAuth 2.0 token not found. See steps above for a fix.');\r",
									"}\r",
									"else\r",
									"{\r",
									"    const tokenAgeInMnutes = Math.floor(Math.floor((new Date().getTime() - pm.request.auth.oauth2.get('timestamp')) / 1000) / 60);\r",
									"    console.warn(`Token age: ${tokenAgeInMnutes} minutes`);\r",
									"    pm.collectionVariables.set('_token', pm.request.auth.oauth2.get('accessToken'));\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "oauth2",
							"oauth2": [
								{
									"key": "client_authentication",
									"value": "body",
									"type": "string"
								},
								{
									"key": "password",
									"value": "{{orgAdminPassword}}{{orgAdminSecurityToken}}",
									"type": "string"
								},
								{
									"key": "username",
									"value": "{{orgAdminUsername}}",
									"type": "string"
								},
								{
									"key": "clientSecret",
									"value": "{{connectedAppConsumerSecret}}",
									"type": "string"
								},
								{
									"key": "clientId",
									"value": "{{connectedAppConsumerKey}}",
									"type": "string"
								},
								{
									"key": "accessTokenUrl",
									"value": "{{orgLoginUrl}}/services/oauth2/token",
									"type": "string"
								},
								{
									"key": "grant_type",
									"value": "password_credentials",
									"type": "string"
								},
								{
									"key": "tokenName",
									"value": "SF Token",
									"type": "string"
								},
								{
									"key": "addTokenTo",
									"value": "header",
									"type": "string"
								},
								{
									"key": "useBrowser",
									"value": true,
									"type": "boolean"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Get Availability by Location Group",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"// Expected strings in collection variables\r",
									"['_token'].forEach(esicv => {\r",
									"    if(!pm.collectionVariables.has(esicv)) {\r",
									"        const msg = 'Expected Postman collection variable not found: ' + esicv;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.exist;\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationGroupIdentifiers...');\r",
									"const locationGroupIdsCommaDelimited = pm.environment.get('locationGroupIdentifiersCommaDelimited');\r",
									"const locationGroupIdsArray = locationGroupIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Group Identifiers: ' + locationGroupIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationGroupIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationGroupIdentifiers', JSON.stringify(locationGroupIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + productStockKeepingUnitsArray.join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"    \r",
									"    const locationGroups = jsonData.locationGroups;\r",
									"    //console.log('Number of Location Groups: ' + locationGroups.length + ' Details:\\r\\n' + JSON.stringify(locationGroups).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locationGroups', locationGroups);\r",
									"    pm.expect(locationGroups.length > 0);\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.exist;\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.be.an('String');\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0]).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationGroupIdentifiers\": {{_locationGroupIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{orgHostMySalesforceFormat}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{orgHostMySalesforceFormat}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Availability by Location",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"// Expected strings in collection variables\r",
									"['_token'].forEach(esicv => {\r",
									"    if(!pm.collectionVariables.has(esicv)) {\r",
									"        const msg = 'Expected Postman collection variable not found: ' + esicv;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.exist;\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationIdentifiers...');\r",
									"const locationIdsCommaDelimited = pm.environment.get('locationIdentifiersCommaDelimited');\r",
									"const locationIdsArray = locationIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Identifiers: ' + locationIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationIdentifiers', JSON.stringify(locationIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + productStockKeepingUnitsArray.join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"\r",
									"    const locations = jsonData.locations;\r",
									"    //console.log('Number of Locations: ' + locations.length + ' Details:\\r\\n' + JSON.stringify(locations).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locations', locations);\r",
									"    pm.expect(locations.length > 0);\r",
									"    pm.expect(locations[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.exist;\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationIdentifiers\": {{_locationIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{orgHostMySalesforceFormat}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{orgHostMySalesforceFormat}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"utils = {",
					"    responseCodeCheck: (pmVar,postmanVar,desiredCode,requestVar)=>{",
					"        pmVar.test(\"Status test\", function () {",
					"            const assert = require('assert').strict;",
					"            let actualResponseCode=pmVar.response.code;",
					"            if(actualResponseCode != desiredCode){",
					"                let errorMessage=requestVar.name+\": Expected response code of: \" + desiredCode + \" but was instead: \" + actualResponseCode;",
					"                console.log(errorMessage);",
					"                postmanVar.setNextRequest(null);",
					"                assert.fail(errorMessage);",
					"            }",
					"        });",
					"     ",
					"    },",
					"    evaluateStatusCheck: (pmVar, postmanVar, endpoint, endpointDescription)=>{",
					"        let jsonData= pmVar.response.json()",
					"        //javascript object is an array of results, get the 1st one",
					"        let result=jsonData;",
					"        //grab the status",
					"        let status=result.status.toLowerCase();",
					"        switch(status){",
					"            case \"expired\":",
					"            case \"failed\":",
					"                console.log(endpointDescription + \" failed with a status of: \"+ status);",
					"                return \"failed-\"+status;",
					"            case \"completed\":",
					"                console.log(endpointDescription + \" success.\");",
					"                return \"success\";",
					"            default:",
					"                let limit = pmVar.environment.get(\"statusCheckLimit\");",
					"                let currentCount = pmVar.environment.get(\"countOfStatusCheck\");",
					"                if(!currentCount){",
					"                    currentCount=0;",
					"                }",
					"                if(limit){",
					"                    console.log(endpointDescription + \" checking for iteration max.\")",
					"                    if(currentCount==limit-1){",
					"                        console.log(endpointDescription + \" reached maximum number of status checks.\");",
					"                        postmanVar.setNextRequest(null);",
					"                        return \"failed-exceeded max allowed status check attempts.\";",
					"                    } else{",
					"                        pmVar.environment.set(\"countOfStatusCheck\",++currentCount);",
					"                        console.log(endpointDescription + \" retrying\");",
					"                        postmanVar.setNextRequest(endpoint);  ",
					"                        return \"retry\";",
					"                    }",
					"                } else{",
					"                    console.log(endpointDescription + \" retrying\");",
					"                    postmanVar.setNextRequest(endpoint);  ",
					"                    return \"retry\";",
					"                }",
					"        }",
					"    }",
					"}",
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "_importJobIds",
			"value": ""
		}
	]
}
