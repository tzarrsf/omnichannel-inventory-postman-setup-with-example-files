{
	"info": {
		"_postman_id": "eb81f53c-b304-4b15-a033-1b2cd41d478b",
		"name": "OCI PLC Collection",
		"description": "# Omnichannel Inventory Postman Setup for Partners\n\n_Created by Tom Zarr with key contributions and examples from Sandra Golden and Jordane Bachelet_\n\n## Background and Use Case\n\nThis material is supplemental to the Omnichannel Inventory Partner Learning Camp course. See the course for the complete setup including configuring OpenSSL and a JWT (JSON Web Token) on Windows.\n\nThis postman collection contains API endpoints from various Salesforce Commerce domains, but the emphasis is uploading inventory levels, monitoring or deleting jobs in that regard, and getting availability levels through the Connect API.\n\nUnlike many other Postman collections, this one is meant to be _user friendly_ and have _meaningful error messages_ when something is not set up correctly or there are issues in the request chains.\n\n## ⚠️ Disclaimers\n\n- This collection is provided as-is. It's not officially supported by Salesforce or covered by SLAs.\n- API documentation is not provided with the collection. Please refer to the official documentation.\n- The documentation for the majority of the endpoints in this collection can be found in these guides, but keep in mind this collection was put together through the lens of a Salesforce org-based developer, not B2C Commerce:\n    - [Omnichannel Inventory Headless API Endpoints](https://help.salesforce.com/s/articleView?id=sf.inv_omnichannel_inventory_headless_apis.htm&type=5)\n    - [Omnichannel Inventory Connect REST APIs](https://help.salesforce.com/s/articleView?id=sf.inv_omnichannel_inventory_connect_rest_apis.htm&type=5)\n    - [getInventoryImport](https://developer.salesforce.com/docs/commerce/commerce-api/references/impex?meta=getInventoryImport)\n    - [deleteInventoryImport](https://developer.salesforce.com/docs/commerce/commerce-api/references/impex?meta=deleteInventoryImport)\n    - [Salesforce Omnichannel Inventory Implementation Guide](https://resources.docs.salesforce.com/latest/latest/en-us/sfdc/pdf/salesforce_omnichannel_inventory_implementation_guide.pdf)\n\n## What this collection is and isn't\n\nThis collection is intended to be used for a Salesforce Order Management standalone setup with Omnichannel Inventory. That isn't to say you can't use it with a Salesforce Org containing other commerce products, just that SOM with OCI is what's targeted.\n\n## Approach\n\n1. I've tried to stay \"close to the metal\" by using the Postman Scripting API directly. There are a few cases where this just isn't possible or realistic because responses are not true JSON or HTTP status codes are reported in the HTML body text, but those should be true exceptions and definitely not the rule.\n2. I wanted oAuth 2.0 to be easy so I could move things around. This is my approach and it's about the best I could come up with given the limitations of the tool: Have a dummy request where you set it once in that folder then everything following just uses Bearer Token. It works and better is the enemy of good enough.\n3. The request chains are long; This is by design. At the risk of being didactic, this is ultimately a _teaching tool_. When it comes to working with APIs I find more detail is better.\n4. Collection variables are calculated and presented before each request.\n5. Tests are applied following each response. If something isn't right I want you to know about it early so I assume little to nothing about a response being successful.\n    \n\n## This collection provides the following\n\n1. Upload Inventory (Happy Path) - using the Headless APIs\n2. Get Running Import Jobs - using the Headless APIs\n3. Get and Delete Import Jobs - using the Headless APIs\n4. Get Inventory Availability (Log In Flow + Connect API) - using Buyer Login and Connect APIs\n5. Get Inventory Availability (oAuth Flow + Connect API) - using oAuth Login and Connect APIs\n    \n\nThere are plans to expand on these basic examples once the B2B, D2C and Order Management collections are rolling.\n\n## Example inventory upload files\n\n_Note_: When uploading inventory level files, the format should contain 1 item per line. Consult the official documentation for details.\n\n1. Single Capricorn Coffee item\n2. Multiple Capricorn Coffee items\n3. Single item in which you supply the SKU\n    \n\n## Connected App Requirements\n\nBecause we're using APIs you'll need to set up two Connected Apps in your org if you want to be able to use both the Headless and Connect APIs:\n\n- Postman_OCI\n- Postman_OCI_ConnectApi\n    \n\nUsing the Headless APIs (such as for loading inventory levels) requires setting up a JSON Web Token. Check the course activity around Headless APIs for details.\n\nYou will need to obtain some values from your Connected App in order to establish connectivity (see: [Variables](https://./#Variables))\n\n## Authentication Approach\n\nAuthentication is generally handled in three ways:\n\n1. Logging in as an Administrator (often used at request chain outset for lookup operations to preserve reusability across orgs). See [Logging in as an Administrator or Buyer](https://./logging-in-as-an-administrator-or-buyer).\n2. Logging in as a 'known good' Buyer (aka Contact under Account with a User). Please note that all three must be set up and this is commonly _not_ going to be the case with a System Administrator account. See [Logging in as an Administrator or Buyer](https://./logging-in-as-an-administrator-or-buyer).\n3. Establishing oAuth 2.0 _once per folder_ and then having subsequent requests set to Bearer Token in the **Authorization** tab. See [oAuth 2.0 is set once per folder where needed](https://./#oauth-20-is-set-once-per-folder-where-needed).\n    \n\n### Logging in as an Administrator or Buyer\n\nThis is handled inline. Just supply the environment with the needed variables like these and the collection and scripting should take care of the rest:\n\n| Name | Description |\n| --- | --- |\n| `orgLoginUrl` | Either `https://login.salesforce.com` (production / trial) or `https://test.salesforce.com` (sandbox) |\n| `orgHost` | Protocol and host portion of the Salesforce org's URL Example: `https://yourusername-august.lightning.force.com` |\n| `orgAdminUsername` | The System Administrator username for the Salesforce org |\n| `orgAdminPassword` | The System Administrator password for the Salesforce org |\n| `orgAdminSecurityToken` | The security token for the Salesforce Org System Administrator User |\n\nIf you need to move this type of Administrator or Buyer authentication scheme around, just copy the request and paste it into another folder or location in the current folder. Copy and paste operations are supported in Postman.\n\n### oAuth 2.0 is set once per folder where needed\n\nPlease don't take on a \"do-it-yourself\" approach with the oAuth 2.0 setup. Why?\n\n1. Most importantly, you don't need to. This has all been completed using variables. There's no guesswork on which log in needs the token appended to the password, etc.\n2. There's scripting which checks if your token set up is correct to begin making requests.\n3. Tokens are passed in subsequent requests using **Bearer Token** authentication on the requests needing it. Just turn it on - done.\n4. This was done \"by design\" so you can easily add your own requests or copy them and move them around with little to no impact whenever oAuth 2.0 is needed.\n5. You can also find and copy the requests named something like **Set your oAuth 2.0 Token in Authorization tab** whenever you need to establish oAuth 2.0 before another request or add it to a folder.\n    \n\n#### Establishing oAuth 2.0 (First Time and Details)\n\n- Look for the request with a name like **Set your oAuth 2.0 Token in Authorization tab**\n- Please don't try to do a bunch of manual work on your token setup or get fancy here. Again, it's all filled in with variables already.\n    \n\nFollow these steps to establish and use your token. These or something very similar will be provided as an error in the **Console** if there's an oAuth error state:\n\n1. Click on the Request with a name like \"Set your oAuth 2.0 Token here in Authorization tab\"\n2. Click the \"Authorization\" tab\n3. Click the \"Get New Access Token\" button\n4. Click the \"Proceed\" button\n5. Click the \"Use Token\" button\n6. Optional - Use the delete button's dropdown option to remove expired tokens (it's best to remove all of them except the newest)\n7. Retry your request(s)\n    \n\n## Error Handling\n\nIt's my intent to trap every reasonably predictable error state and save anyone using this collection time. I welcome your feedback on that front. That said, I can't cover every single org configuration or set of data and this is where you come in as a partner. Below are some of the common cases I have tried to account for so the request chains can inform you when something's wrong or at least provide hints to help troubleshoot what you're seeing.\n\n### Clear Collection Variables\n\nIt's recommended you stick to the pattern of having this as the first step in your folder as it does a few things to ensure your request chain data is kept consistent:\n\n1. The **Pre-request** tab makes sure that your environment is selected and stops the chain if not (dead programs tell no lies):\n    \n\n```\n// Check for environment selection\nif(pm.environment.name === undefined) {\n    const msg = 'No Postman environment selected or set.';\n    pm.expect.fail(msg);\n}\n\n ```\n\n1. The **Pre-request** tab makes sure that it clears out the collection variables:\n    \n\n```\n// Clean up the variables from the collection set throughout the various calls\npm.collectionVariables.clear();\n\n ```\n\n1. The **Test** tab ensures the collection is indeed empty:\n    \n\n```\npm.test('Make sure collection variables are clean', () => {\n    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\n});\n\n ```\n\n### Request names are pulled in dynamically in both the Pre-request and Test code\n\nWhatever the request is named in the Postman user interface is reflected dynamically by these code snippets:\n\n`console.log(`${pm.info.requestName} Pre-request Script...`);`\n\n`console.log(`${pm.info.requestName} Tests...`);`\n\nIf you call your request \"Heinz 57\" you will see `Heinz 57 Pre-request Script...` or `Heinz 57 Tests...` in the console accordingly. You can drill into your request and response bodies as needed knowing what was passed to the endpoint.\n\n### Requests must meet Preconditions\n\nIf **environment** variables are expected for a request they are tested on the Pre-request script tab and if not found the test run should go to a hard fail state. Just look for the error (red text) in the Console.\n\n```\n// Expected strings in environment variables\n['host', 'tenantId', 'bearerToken'].forEach(esiev => {\n    if(!pm.environment.has(esiev)) {\n        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\n        pm.expect.fail(msg);\n    }\n    pm.expect(pm.environment.get(esiev)).to.exist;\n    pm.expect(pm.environment.get(esiev)).to.be.an('string');\n});\n\n ```\n\nIf **collection** variables are expected they are tested on the Pre-request script tab. Like the environment variables, the test run should go to a hard fail state and you should find a _meaningful_ error in the Console.\n\n```\n// Expected strings in collection variables\n['_webStoreId', '_token', '_orgId'].forEach(esicv => {\n    if(pm.collectionVariables.get(esicv) === undefined) {\n        const msg = 'Expected Postman collection variable not found: ' + esicv;\n        pm.expect.fail(msg);\n    }\n    pm.expect(pm.collectionVariables.get(esicv)).to.exist;\n    pm.expect(pm.collectionVariables.get(esicv)).to.be.an('string');\n});\n\n ```\n\n### Collection variables are listed in each Pre-request\n\nThis code snippet allows you to see things _before_ each request is made in the **Pre-Request Script** tab:\n\n```\nconsole.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\n\n ```\n\nExample of collection variables being printed to the console in a Pre-request script:\n\n```\nCollection variables before:↵\n_instanceUrl: https://toms-org.my.salesforce.com↵\n_locationGroupIdentifiers: [\"LocationGroup01\"]↵\n_orgId: 00DHn0000YYYYYYYYY↵\n_productStockKeepingUnits: [\"PROSE\",\"B-C-COFMAC-001\",\"ESP-IOT-1\",\"ID-PEM\",\"PS-EL\",\"PS-INF\",\"TR-COFMAC-001\"]↵\n_token: 0xdeadbeef!0x8badfood!0xfeedfacecafebeefx.01123581321345589144233377610↵\n_userId: 005HnXXXXXXXXXXXXX\n\n ```\n\n## Variables\n\n> ⚠️ **Note**: You must set up your environment variables correctly for all of this to work. Collection variables are typically calculated and assigned between requests (in the **Test** tab script) and used in subsequent requests. The naming convention used in the collection is to prefix collection variable keys with an underscore like `_tomsVariableKey` while an environment variable should not contain an underscore. Example: `tomsVariableKey`. I would never recommend writing to environment variables at runtime. My approach is to keep these consistent across the collection and all folders across the collection and use them only when changing orgs, storefronts or users. \n  \n\nThese are some _bad_ examples. You shouldn't see calls like these in the collection and it's strongly recommended that you do not create them this way to avoid needless debugging:\n\n1. `pm.collectionVariables.set('myVariable', 'My new value');`\n2. `pm.collectionVariables.get('myVariable');`\n3. `pm.environment.set('_myVariable', 'My new value');`\n4. `pm.environment.get('_myVariable');`\n    \n\nThese are good examples as they adhere to the established naming convention and it's clear which dictionary we're using when the name is seen in the Console:\n\n1. `pm.collectionVariables.set('_myVariable', 'My new value');`\n2. `pm.collectionVariables.get('_myVariable');`\n3. `pm.environment.set('myVariable', 'My new value');`\n4. `pm.environment.get('myVariable');`\n    \n\nEvery coder has their preferences and principles. I don't like mixing sources like dictionaries for retrieving a value by key. A value with an underscore prefix in this naming convention should correspond to pm.collectionVariables and one without should come from pm.environment. I don't use a context stand-in object that allows pulling or pushing a value by key from either pm.collectionVariables or pm.environment at runtime. I believe strongly that a few coding principals such as singular definition and not coding by coincidence - even with tests, and especially with tests can save time. If those terms are not familiar I'd like to recommend the book \"The Pragmatic Programmer\" as it could replace many on your shelf or device.\n\n### Input values\n\n#### Some Environment variables are used for lookups to support reuse\n\n1. webstoreName (resolves to a WebStore Id)\n2. buyerAccountName (resolves to an Account Id)\n    \n\n#### Some Environment variables can be used to provide comma delimited values\n\n1. productNamesCommaDelimited (used in the B2B Postman collection and resolves to a list of Product2 Ids)\n2. productStockKeepingUnitsCommaDelimited\n3. locationGroupIdentifiersCommaDelimited\n4. locationIdentifiersCommaDelimited\n    \n\n#### Some Environment variables can be used to provide a single string value\n\n1. productSearchTerm (used in the B2B Postman collection)\n    \n\n## Standardized variables\n\n⚠️ **Note**: The naming convention found here is used across other Salesforce Commerce product Postman collections in the Partner Readiness space when possible to support reuse.\n\nThis Postman collection relies on the following variables:\n\n| Name | Description | Location |\n| --- | --- | --- |\n| `orgLoginUrl` | Either `https://login.salesforce.com` (production/trial) or `https://test.salesforce.com` (sandbox) | User supplied |\n| `orgHost` | Protocol and host portion of the Salesforce org's URL | User supplied. Example: `https://yourusername-august.lightning.force.com` |\n| `orgAdminUsername` | The System Administrator username for the Salesforce org | User supplied |\n| `orgAdminPassword` | The System Administrator password for the Salesforce org | User supplied |\n| `orgAdminSecurityToken` | The security token for the Salesforce Org System Administrator User | Autogenerated |\n| `orgHostMySalesforceFormat` | The protocol and host portion of the Salesforce org's URL in 'my.salesforce.com' format. Useful for avoiding redirection problems and 'Invalid Session Id' errors post authentication | User supplied. Example: `https://yourusername-august.my.salesforce.com` |\n| `orgId` | The Salesforce.com Organization ID for the Salesforce org | Setup > Company Information |\n| `apiVersion` | The Salesforce API version (e.g. 58.0). | User supplied. Most recent value recommended. |\n| `connectedAppConsumerKey` | The Consumer Secret value for the Connected App in the Salesforce org. | Setup > App Manager > Connected App Record > View > Manage Consumer Details |\n| `connectedAppConsumerSecret` | The Consumer Secret value in the Connected App. | Setup > App Manager > Connected App Record > View > Manage Consumer Details |\n| `host` | The OCI Host for the Salesforce Org | Setup > Omnichannel Inventory > 'Base URL for Inventory API Calls' |\n| `tenantId` | The OCI Tenant Id for the Salesforce org | Setup > Omnichannel Inventory > 'Tenant Group ID' |\n| `JWT` | JSON Web Token | Consult the course for setup procedure |\n| `bearerToken` | The bearer token sent in the Authorization header | Autogenerated |\n| `productStockKeepingUnitsCommaDelimited` | The Stock Keeping Unit(s) for the products needing inventory levels | User supplied. Must be comma delimited. Example 1: `PROSE,B-C-COFMAC-001,ESP-IOT-1,ID-PEM,PS-EL,PS-INF,TR-COFMAC-001` Example 2: `ID-PEM` |\n| `locationGroupIdentifiersCommaDelimited` | The Location Group(s) for the availability query | User supplied. Must be comma delimited. Example 1: `LocationGroup01` Example 2: `LocationGroup01,LocationGroup02,WestCoastDistributionChain` |\n| `locationIdentifiersCommaDelimited` | The Location(s) for the availability query | User supplied. Must be comma delimited. Example 1: `Warehouse01` Example 2: `Warehouse01,Store056,Pier37` |\n| `importsUploadLinkPostBody` | The pseudo JSON file content posted for inventory level uploads | Provided for example products and can be modified to suit your needs |\n| `webstoreName` | Name of the webstore used to look up a corresponding Id | The value specified when the store / site was created such as 'B2B LWR Enhanced Store from TSO.' Can be found in the Commerce App under 'Stores.' |\n| `buyerUsername` | Registered B2B Buyer User's username. | User supplied. |\n| `buyerPassword` | Registered B2B Buyer User's password. | User supplied. |\n| `buyerAccountName` | Name of the Account used to look up the Accoujnt Id which is tied to the Buyer User. | User supplied. Example: `United Coffee Bean Corp` |\n\nPlease consult the curriculum and course documentation for additional details.\n\nEnjoy the collection!\n\n- Tom Zarr ([tzarr@salesforce.com](https://mailto:tzarr@salesforce.com)) September, 2023",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "8399406"
	},
	"item": [
		{
			"name": "Upload Inventory (Happy Path)",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Get Access Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let jsonData = pm.response.json();\r",
									"pm.environment.set('bearerToken','Bearer ' + jsonData.access_token);"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.expect(pm.environment.name !== null);\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','JWT'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Host",
								"value": "login.salesforce.com",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "grant_type",
									"value": "urn:ietf:params:oauth:grant-type:jwt-bearer",
									"type": "text"
								},
								{
									"key": "assertion",
									"value": "{{JWT}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/oauth2/token",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Authenticate into Org",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 204', () => {",
									"    pm.response.to.have.status(204);",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.expect(pm.environment.name !== null);\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'tenantId', 'bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/internal/v1/organizations/{{tenantId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"internal",
								"v1",
								"organizations",
								"{{tenantId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Inventory Import Link",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));",
									"",
									"pm.expect(pm.environment.name !== null);",
									"",
									"// Expected strings in environment variables",
									"['host', 'tenantId', 'bearerToken', 'locationInventoryImportInitiateBody'].forEach(esiev => {",
									"    if(!pm.environment.has(esiev)) {",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;",
									"        pm.expect.fail(msg);",
									"    }",
									"    pm.expect(pm.environment.get(esiev)).to.exist;",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');",
									"});",
									"",
									"let importInitiateBody = JSON.stringify({'fileName': pm.environment.get('locationInventoryImportFileName'),'linkDuration': 60});",
									"pm.environment.set('locationInventoryImportInitiateBody',importInitiateBody);",
									"",
									"pm.environment.set('locationInventoryImportId',null);",
									"pm.environment.set('locationInventoryImportStatusLink',null);",
									"pm.environment.set('locationInventoryImportUploadLink',null);",
									"pm.environment.set('locationInventoryImportResultsLink',null);",
									"",
									"// Reset to account for the other imports/exports using the same variable",
									"pm.environment.set('countOfStatusCheck',null);"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 200', () => {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response is valid and has a JSON body', () => {",
									"     pm.response.to.be.success;",
									"     pm.response.to.be.withBody;",
									"     pm.response.to.be.json;",
									"});",
									"",
									"/*",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.",
									"*/",
									"try {",
									"    const jsonData = pm.response.json();",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);",
									"} catch(e) {",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');",
									"    }",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"type": "text",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{{locationInventoryImportInitiateBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				},
				{
					"name": "5. Post Inventory Import File",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'locationInventoryImportUploadLink', 'importsUploadLinkPostBody'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "ImportsUploadLinkPostBody",
									"value": "{{importsUploadLinkPostBody}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{host}}{{locationInventoryImportUploadLink}}",
							"host": [
								"{{host}}{{locationInventoryImportUploadLink}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "6. Get Inventory Import Status",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 200', () => {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"let currentStatus = utils.evaluateStatusCheck(pm, postman, 'locationInventoryImportStatus', 'Location inventory import, ');",
									"pm.expect(currentStatus).to.be.oneOf(['retry', 'success']);",
									"",
									"switch (currentStatus) {",
									"    case 'retry':",
									"        setTimeout(function() {}, 3000);",
									"        break;",
									"    case 'success':",
									"        let jsonData = pm.response.json();",
									"        let locationInventoryImportResultsLink = jsonData.import.fullResults.href;",
									"        pm.environment.set('locationInventoryImportResultsLink', locationInventoryImportResultsLink);",
									"        break;",
									"    default:",
									"        pm.expect.fail('currentStatus was not retry or success');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.expect(pm.environment.name !== null);\r",
									"pm.expect(pm.environment.get('locationInventoryImportStatusLink')).to.exist;\r",
									"pm.expect(pm.environment.get('locationInventoryImportStatusLink')).to.be.an('string');\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'locationInventoryImportStatusLink', 'bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}{{locationInventoryImportStatusLink}}",
							"host": [
								"{{host}}{{locationInventoryImportStatusLink}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "7. Get Inventory Import Results",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"utils.responseCodeCheck(pm, postman, 200, request);",
									"",
									"try {",
									"    //this will fail if there are errors, because the response body when there are errors is not standard json and can't be converted to json.",
									"    let jsonData = pm.response.json();",
									"    let currentStatus = jsonData.status;",
									"    console.log('Final result status is: ' + currentStatus);",
									"    pm.expect(currentStatus).to.eql('COMPLETED_WITHOUT_ERRORS');",
									"} catch (err) {",
									"    postman.setNextRequest(null);",
									"    pm.expect.fail('There were errors importing. See the response body for specifics.')",
									"}",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host', 'locationInventoryImportResultsLink', 'bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}{{locationInventoryImportResultsLink}}",
							"host": [
								"{{host}}{{locationInventoryImportResultsLink}}"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get Import Jobs",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Get Access Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let jsonData = pm.response.json();\r",
									"pm.environment.set('bearerToken','Bearer ' + jsonData.access_token);\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','JWT'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Host",
								"value": "login.salesforce.com",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "grant_type",
									"value": "urn:ietf:params:oauth:grant-type:jwt-bearer",
									"type": "text"
								},
								{
									"key": "assertion",
									"value": "{{JWT}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/oauth2/token",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Authenticate into Org",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 204', () => {",
									"    pm.response.to.have.status(204);",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/internal/v1/organizations/{{tenantId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"internal",
								"v1",
								"organizations",
								"{{tenantId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Jobs",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response and save the import job ids array to collection variables', () => {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.expect(jsonData.imports).to.exist;\r",
									"    pm.expect(jsonData.imports).to.be.an('array');\r",
									"    const importJobIds = jsonData.imports;\r",
									"    console.log('Number of Import Job Ids: ' + importJobIds.length + ' Details:\\r\\n' + importJobIds.join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_importJobIds', importJobIds);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get and Delete Import Jobs",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Get Access Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let jsonData = pm.response.json();\r",
									"pm.environment.set(\"bearerToken\",\"Bearer \" + jsonData.access_token);"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','JWT'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"warning": "This is a duplicate header and will be overridden by the Content-Type header generated by Postman.",
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Host",
								"value": "login.salesforce.com",
								"type": "text"
							}
						],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "grant_type",
									"value": "urn:ietf:params:oauth:grant-type:jwt-bearer",
									"type": "text"
								},
								{
									"key": "assertion",
									"value": "{{JWT}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "https://login.salesforce.com/services/oauth2/token",
							"protocol": "https",
							"host": [
								"login",
								"salesforce",
								"com"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Authenticate into Org",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);",
									"",
									"pm.test('Status code is 204', () => {",
									"    pm.response.to.have.status(204);",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"type": "text",
								"value": "{{bearerToken}}"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/internal/v1/organizations/{{tenantId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"internal",
								"v1",
								"organizations",
								"{{tenantId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Jobs",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Validate the response and save the import job ids array to collection variables', () => {\r",
									"    pm.expect(jsonData.imports).to.exist;\r",
									"    pm.expect(jsonData.imports).to.be.an('array');\r",
									"    const importJobIds = jsonData.imports;\r",
									"    console.log('Number of Import Job Ids: ' + importJobIds.length + ' Details:\\r\\n' + importJobIds.join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_importJobIds', importJobIds);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				},
				{
					"name": "5. Delete First Job in Collection",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.test('Status code is 204', () => {\r",
									"    pm.response.to.have.status(204);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"const importJobIds = pm.collectionVariables.get('_importJobIds');\r",
									"\r",
									"if(importJobIds === undefined || importJobIds === null || importJobIds.length === 0) {\r",
									"    pm.expect.fail('No jobs to delete. Try running the \"Upload Inventory (Happy Path)\" folder once or twice to create some.');\r",
									"}\r",
									"\r",
									"pm.collectionVariables.set('_importJobId', importJobIds[0]);\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"// Expected strings in collection variables\r",
									"['_importJobId'].forEach(esicv => {\r",
									"    if(!pm.collectionVariables.has(esicv)) {\r",
									"        const msg = 'Expected Postman collection variable not found: ' + esicv;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.exist;\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports/{{_importJobId}}",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports",
								"{{_importJobId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "6. Get Jobs",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Validate the response and save the import job ids array to collection variables', () => {\r",
									"    pm.expect(jsonData.imports).to.exist;\r",
									"    pm.expect(jsonData.imports).to.be.an('array');\r",
									"    const importJobIds = jsonData.imports;\r",
									"    console.log('Number of Import Job Ids: ' + importJobIds.length + ' Details:\\r\\n' + importJobIds.join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_importJobIds', importJobIds);\r",
									"});\r",
									"\r",
									"/*\r",
									"There's a case in which the response is not JSON and the HTTP 403 Forbidden status doesn't come through as a header. However, it's in the HTML body.\r",
									"*/\r",
									"try {\r",
									"    pm.environment.set('locationInventoryImportId', jsonData.importId);\r",
									"    pm.environment.set('locationInventoryImportStatusLink', jsonData.importStatusLink);\r",
									"    pm.environment.set('locationInventoryImportUploadLink', jsonData.uploadLink);\r",
									"} catch(e) {\r",
									"    const bodyToUpper = (pm.response.text() ?? '').toLocaleUpperCase();\r",
									"    if(bodyToUpper.lastIndexOf('403') > -1 || bodyToUpper.lastIndexOf('FORBIDDEN') > -1) {\r",
									"        pm.expect.fail('Response does not contain JSON. You may need to generate a new JWT and assign it to the JWT environment variable.');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['host','tenantId','bearerToken'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{bearerToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{host}}/inventory/impex/v1/organizations/{{tenantId}}/availability-records/imports",
							"host": [
								"{{host}}"
							],
							"path": [
								"inventory",
								"impex",
								"v1",
								"organizations",
								"{{tenantId}}",
								"availability-records",
								"imports"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get Availability (Log In Flow + Connect API)",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Authenticate Connected App",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.ok;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the access token is found in the body and save it to the variables', () => {\r",
									"    const data = pm.response.json();\r",
									"    pm.expect(data.token_type).to.exist;\r",
									"    pm.expect(data.token_type).to.be.a.string;\r",
									"    pm.expect(data.access_token).to.exist;\r",
									"    pm.expect(data.access_token).to.be.a.string;\r",
									"    const id = data.id.split('/');\r",
									"\r",
									"    pm.collectionVariables.set('_token', data.access_token);\r",
									"    pm.collectionVariables.set('_instanceUrl', data.instance_url);\r",
									"    pm.collectionVariables.set('_userId', id.pop());\r",
									"    pm.collectionVariables.set('_orgId', id.pop());\r",
									"});\r",
									"\r",
									"console.debug('token: ' + pm.collectionVariables.get('_token'));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "{{orgAdminUsername}}",
									"type": "text"
								},
								{
									"key": "password",
									"value": "{{orgAdminPassword}}{{orgAdminSecurityToken}}",
									"type": "text"
								},
								{
									"key": "grant_type",
									"value": "password",
									"type": "text"
								},
								{
									"key": "client_id",
									"value": "{{connectedAppConsumerKey}}",
									"type": "text"
								},
								{
									"key": "client_secret",
									"value": "{{connectedAppConsumerSecret}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/oauth2/token",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"oauth2",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Log in as System Administrator (SOAP)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(JSON.parse(JSON.stringify(pm.collectionVariables.values)).map((v) => v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"pm.test('Status code is 200', () => {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test('Validate the access token is found in the body and save it to the variables', () => {\r",
									"    const result = xml2Json(pm.response.text())['soapenv:Envelope']['soapenv:Body'].loginResponse.result;\r",
									"    const url = result.serverUrl.split('/');\r",
									"\r",
									"    pm.expect(result.sessionId).to.exist;\r",
									"    pm.expect(result.sessionId).to.be.a.string;\r",
									"\r",
									"    pm.collectionVariables.set('_token', result.sessionId);\r",
									"    pm.collectionVariables.set('_instanceUrl', url[0] + '//' + url[2]);\r",
									"    pm.collectionVariables.set('_userId', result.userId);\r",
									"    pm.collectionVariables.set('_orgId', result.userInfo.organizationId);\r",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgLoginUrl','apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "text/xml; charset=UTF-8",
								"type": "text"
							},
							{
								"key": "SOAPAction",
								"value": "login",
								"type": "text"
							},
							{
								"key": "Accept",
								"value": "text/xml",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<env:Envelope xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:n1=\"urn:partner.soap.sforce.com\"\r\n    xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\">\r\n    <env:Body>\r\n        <n1:login>\r\n            <n1:username><![CDATA[{{orgAdminUsername}}]]></n1:username>\r\n            <n1:password><![CDATA[{{orgAdminPassword}}]]></n1:password>\r\n        </n1:login>\r\n    </env:Body>\r\n</env:Envelope>"
						},
						"url": {
							"raw": "{{orgLoginUrl}}/services/Soap/u/{{apiVersion}}",
							"host": [
								"{{orgLoginUrl}}"
							],
							"path": [
								"services",
								"Soap",
								"u",
								"{{apiVersion}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Availability by Location Group",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationGroupIdentifiers...');\r",
									"const locationGroupIdsCommaDelimited = pm.environment.get('locationGroupIdentifiersCommaDelimited');\r",
									"const locationGroupIdsArray = locationGroupIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Group Identifiers: ' + locationGroupIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationGroupIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationGroupIdentifiers', JSON.stringify(locationGroupIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + productStockKeepingUnitsArray.join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"    \r",
									"    const locationGroups = jsonData.locationGroups;\r",
									"    console.log('Number of Location Groups: ' + locationGroups.length + ' Details:\\r\\n' + JSON.stringify(locationGroups).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locationGroups', locationGroups);\r",
									"    pm.expect(locationGroups.length > 0);\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.exist;\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.be.an('String');\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0]).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationGroupIdentifiers\": {{_locationGroupIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{_instanceUrl}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{_instanceUrl}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				},
				{
					"name": "5. Get Availability by Location",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationIdentifiers...');\r",
									"const locationIdsCommaDelimited = pm.environment.get('locationIdentifiersCommaDelimited');\r",
									"const locationIdsArray = locationIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Identifiers: ' + locationIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationIdentifiers', JSON.stringify(locationIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + JSON.stringify(productStockKeepingUnitsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"\r",
									"    const locations = jsonData.locations;\r",
									"    console.log('Number of Locations: ' + locations.length + ' Details:\\r\\n' + JSON.stringify(locations).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locations', locations);\r",
									"    pm.expect(locations.length > 0);\r",
									"    pm.expect(locations[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.exist;\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationIdentifiers\": {{_locationIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{_instanceUrl}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{_instanceUrl}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Get Availability (oAuth Flow + Connect API)",
			"item": [
				{
					"name": "1. Clear Collection Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"\r",
									"// Check for environment selection\r",
									"if(pm.environment.name === undefined) {\r",
									"    const msg = 'No Postman environment selected or set.';\r",
									"    pm.expect.fail(msg);\r",
									"}\r",
									"\r",
									"// Clean up the variables from the collection set throughout the various calls\r",
									"pm.collectionVariables.clear();"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Make sure collection variables are clean', () => {\r",
									"    pm.expect(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value)).to.be.an('array').empty;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "2. Set your oAuth 2.0 Token in Authorization tab",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Checking oAuth has been set up...');\r",
									"\r",
									"const isTokenMissing = pm.request.auth === undefined\r",
									"    || pm.request.auth.oauth2 === undefined\r",
									"    || !pm.request.auth.oauth2.has('accessToken')\r",
									"    || pm.request.auth.oauth2.get('accessToken') === undefined\r",
									"    || pm.request.auth.oauth2.get('accessToken') === null\r",
									"    || pm.request.auth.oauth2.get('accessToken').length === 0;\r",
									"\r",
									"pm.test('oAuth 2.0 Token is present', () => {\r",
									"    pm.expect(isTokenMissing === false);\r",
									"    pm.expect(pm.request.auth).to.exist;\r",
									"    pm.expect(pm.request.auth).to.be.an('object');\r",
									"    pm.expect(pm.request.auth.oauth2).to.exist;\r",
									"    pm.expect(pm.request.auth.oauth2).to.be.an('object');\r",
									"    pm.expect(pm.request.auth.oauth2.has('accessToken')).to.be.true;\r",
									"    pm.expect(pm.request.auth.oauth2.get('accessToken')).to.exist;\r",
									"    pm.expect(pm.request.auth.oauth2.get('accessToken')).to.be.an('string').with.length.greaterThan(0);\r",
									"});\r",
									"\r",
									"if(isTokenMissing) {\r",
									"    const msg = 'No Soup for you! oAuth 2.0 token not found. Steps to fix the issue:\\r\\n' + \r",
									"    '1. Click on the Request with a name like \"Set your oAuth 2.0 Token here in Authorization tab\"\\r\\n' +\r",
									"    '2. Click the \"Authorization\" tab\\r\\n' + \r",
									"    '3. Click the \"Get New Access Token\" button\\r\\n' +\r",
									"    '4. Click the \"Proceed\" button\\r\\n' + \r",
									"    '5. Click the \"Use Token\" button\\r\\n' +\r",
									"    '6. Retry your request';\r",
									"    console.log(msg);\r",
									"    pm.expect.fail('No Soup for you! oAuth 2.0 token not found. See steps above for a fix.');\r",
									"}\r",
									"else\r",
									"{\r",
									"    const tokenAgeInMnutes = Math.floor(Math.floor((new Date().getTime() - pm.request.auth.oauth2.get('timestamp')) / 1000) / 60);\r",
									"    console.warn(`Token age: ${tokenAgeInMnutes} minutes`);\r",
									"    pm.collectionVariables.set('_token', pm.request.auth.oauth2.get('accessToken'));\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "oauth2",
							"oauth2": [
								{
									"key": "client_authentication",
									"value": "body",
									"type": "string"
								},
								{
									"key": "password",
									"value": "{{orgAdminPassword}}{{orgAdminSecurityToken}}",
									"type": "string"
								},
								{
									"key": "username",
									"value": "{{orgAdminUsername}}",
									"type": "string"
								},
								{
									"key": "clientSecret",
									"value": "{{connectedAppConsumerSecret}}",
									"type": "string"
								},
								{
									"key": "clientId",
									"value": "{{connectedAppConsumerKey}}",
									"type": "string"
								},
								{
									"key": "accessTokenUrl",
									"value": "{{orgLoginUrl}}/services/oauth2/token",
									"type": "string"
								},
								{
									"key": "grant_type",
									"value": "password_credentials",
									"type": "string"
								},
								{
									"key": "tokenName",
									"value": "SF Token",
									"type": "string"
								},
								{
									"key": "addTokenTo",
									"value": "header",
									"type": "string"
								},
								{
									"key": "useBrowser",
									"value": true,
									"type": "boolean"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "postman-echo.com/get",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				},
				{
					"name": "3. Get Availability by Location Group",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"// Expected strings in collection variables\r",
									"['_token'].forEach(esicv => {\r",
									"    if(!pm.collectionVariables.has(esicv)) {\r",
									"        const msg = 'Expected Postman collection variable not found: ' + esicv;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.exist;\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationGroupIdentifiers...');\r",
									"const locationGroupIdsCommaDelimited = pm.environment.get('locationGroupIdentifiersCommaDelimited');\r",
									"const locationGroupIdsArray = locationGroupIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Group Identifiers: ' + locationGroupIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationGroupIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationGroupIdentifiers', JSON.stringify(locationGroupIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + productStockKeepingUnitsArray.join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"    \r",
									"    const locationGroups = jsonData.locationGroups;\r",
									"    //console.log('Number of Location Groups: ' + locationGroups.length + ' Details:\\r\\n' + JSON.stringify(locationGroups).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locationGroups', locationGroups);\r",
									"    pm.expect(locationGroups.length > 0);\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.exist;\r",
									"    pm.expect(locationGroups[0].locationGroupIdentifier).to.be.an('String');\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0]).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locationGroups[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationGroupIdentifiers\": {{_locationGroupIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{orgHostMySalesforceFormat}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{orgHostMySalesforceFormat}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				},
				{
					"name": "4. Get Availability by Location",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Pre-request Script...`);\r",
									"console.log('Collection variables before:\\r\\n'.concat(pm.collectionVariables.values.map((v) =>  v.key + ': ' + v.value).sort().join('\\r\\n')));\r",
									"\r",
									"// Expected strings in environment variables\r",
									"['orgHostMySalesforceFormat', 'apiVersion'].forEach(esiev => {\r",
									"    if(!pm.environment.has(esiev)) {\r",
									"        const msg = `Expected Postman environment variable not found: '${esiev}' in environment: '${pm.environment.name}'.`;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.environment.get(esiev)).to.exist;\r",
									"    pm.expect(pm.environment.get(esiev)).to.be.an('string');\r",
									"});\r",
									"\r",
									"// Expected strings in collection variables\r",
									"['_token'].forEach(esicv => {\r",
									"    if(!pm.collectionVariables.has(esicv)) {\r",
									"        const msg = 'Expected Postman collection variable not found: ' + esicv;\r",
									"        pm.expect.fail(msg);\r",
									"    }\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.exist;\r",
									"    pm.expect(pm.collectionVariables.get(esicv)).to.be.an('string');\r",
									"});\r",
									"\r",
									"console.log('Parsing and assigning locationIdentifiers...');\r",
									"const locationIdsCommaDelimited = pm.environment.get('locationIdentifiersCommaDelimited');\r",
									"const locationIdsArray = locationIdsCommaDelimited.split(',');\r",
									"console.log('# of Location Identifiers: ' + locationIdsArray.length + ' Details:\\r\\n' + JSON.stringify(locationIdsArray).split(',').join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_locationIdentifiers', JSON.stringify(locationIdsArray));\r",
									"\r",
									"console.log('Parsing and assigning productStockKeepingUnits...');\r",
									"const productStockKeepingUnitsCommaDelimited = pm.environment.get('productStockKeepingUnitsCommaDelimited');\r",
									"const productStockKeepingUnitsArray = productStockKeepingUnitsCommaDelimited.split(',');\r",
									"console.log('# of Product Stock Keeping Units: ' + productStockKeepingUnitsArray.length + ' Details:\\r\\n' + productStockKeepingUnitsArray.join(',\\r\\n'));\r",
									"pm.collectionVariables.set('_productStockKeepingUnits', JSON.stringify(productStockKeepingUnitsArray));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"console.log(`${pm.info.requestName} Tests...`);\r",
									"\r",
									"pm.test('Status code is 201', () => {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"const jsonData = pm.response.json();\r",
									"\r",
									"pm.test('Success true in response', () => {\r",
									"    pm.expect(jsonData.success).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test('Response is valid and has a JSON body', () => {\r",
									"     pm.response.to.be.success;\r",
									"     pm.response.to.be.withBody;\r",
									"     pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test('Validate the response', () => {\r",
									"    pm.expect(jsonData.locationGroups).to.exist;\r",
									"    pm.expect(jsonData.locationGroups).to.be.an('array');\r",
									"\r",
									"    const locations = jsonData.locations;\r",
									"    //console.log('Number of Locations: ' + locations.length + ' Details:\\r\\n' + JSON.stringify(locations).split(',').join(',\\r\\n'));\r",
									"    pm.collectionVariables.set('_locations', locations);\r",
									"    pm.expect(locations.length > 0);\r",
									"    pm.expect(locations[0].inventoryRecords).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords).to.be.an('array');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToFulfill).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].availableToOrder).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].onHand).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].reserved).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].safetyStockCount).to.be.an('Number');\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.exist;\r",
									"    pm.expect(locations[0].inventoryRecords[0].stockKeepingUnit).to.be.an('String');\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.exist;\r",
									"    pm.expect(locations[0].locationIdentifier[0]).to.be.an('String');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"locationIdentifiers\": {{_locationIdentifiers}},\r\n    \"stockKeepingUnits\": {{_productStockKeepingUnits}},\r\n    \"useCache\": \"false\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{orgHostMySalesforceFormat}}/services/data/v{{apiVersion}}/commerce/oci/availability/availability-records/actions/get-availability",
							"host": [
								"{{orgHostMySalesforceFormat}}"
							],
							"path": [
								"services",
								"data",
								"v{{apiVersion}}",
								"commerce",
								"oci",
								"availability",
								"availability-records",
								"actions",
								"get-availability"
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"utils = {",
					"    responseCodeCheck: (pmVar,postmanVar,desiredCode,requestVar)=>{",
					"        pmVar.test(\"Status test\", function () {",
					"            const assert = require('assert').strict;",
					"            let actualResponseCode=pmVar.response.code;",
					"            if(actualResponseCode != desiredCode){",
					"                let errorMessage=requestVar.name+\": Expected response code of: \" + desiredCode + \" but was instead: \" + actualResponseCode;",
					"                console.log(errorMessage);",
					"                postmanVar.setNextRequest(null);",
					"                assert.fail(errorMessage);",
					"            }",
					"        });",
					"     ",
					"    },",
					"    evaluateStatusCheck: (pmVar, postmanVar, endpoint, endpointDescription)=>{",
					"        let jsonData= pmVar.response.json()",
					"        //javascript object is an array of results, get the 1st one",
					"        let result=jsonData;",
					"        //grab the status",
					"        let status=result.status.toLowerCase();",
					"        switch(status){",
					"            case \"expired\":",
					"            case \"failed\":",
					"                console.log(endpointDescription + \" failed with a status of: \"+ status);",
					"                return \"failed-\"+status;",
					"            case \"completed\":",
					"                console.log(endpointDescription + \" success.\");",
					"                return \"success\";",
					"            default:",
					"                let limit = pmVar.environment.get(\"statusCheckLimit\");",
					"                let currentCount = pmVar.environment.get(\"countOfStatusCheck\");",
					"                if(!currentCount){",
					"                    currentCount=0;",
					"                }",
					"                if(limit){",
					"                    console.log(endpointDescription + \" checking for iteration max.\")",
					"                    if(currentCount==limit-1){",
					"                        console.log(endpointDescription + \" reached maximum number of status checks.\");",
					"                        postmanVar.setNextRequest(null);",
					"                        return \"failed-exceeded max allowed status check attempts.\";",
					"                    } else{",
					"                        pmVar.environment.set(\"countOfStatusCheck\",++currentCount);",
					"                        console.log(endpointDescription + \" retrying\");",
					"                        postmanVar.setNextRequest(endpoint);  ",
					"                        return \"retry\";",
					"                    }",
					"                } else{",
					"                    console.log(endpointDescription + \" retrying\");",
					"                    postmanVar.setNextRequest(endpoint);  ",
					"                    return \"retry\";",
					"                }",
					"        }",
					"    }",
					"}",
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "_token",
			"value": ""
		},
		{
			"key": "_locationGroupIdentifiers",
			"value": ""
		},
		{
			"key": "_productStockKeepingUnits",
			"value": ""
		},
		{
			"key": "_locationGroups",
			"value": ""
		},
		{
			"key": "_locationIdentifiers",
			"value": ""
		},
		{
			"key": "_locations",
			"value": ""
		},
		{
			"key": "_instanceUrl",
			"value": ""
		},
		{
			"key": "_userId",
			"value": ""
		},
		{
			"key": "_orgId",
			"value": ""
		}
	]
}
